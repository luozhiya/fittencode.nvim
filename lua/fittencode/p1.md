## spawn

```lua
--[[
-- 其他模块使用 spawn 示例
local process = require('fittencode.process.spawn')

local p = process.spawn('ls', {'-l'}, {
    stdin = nil
})

p:on('stdout', function(data)
    print('Output:', data)
end)

p:on('exit', function(code)
    print('Exit with code:', code)
end)
--]]

local M = {}

local function create_process()
    return {
        _callbacks = { stdout = {}, stderr = {}, exit = {}, error = {}, abort = {} },
        aborted = false,
        on = function(self, event, cb)
            if self._callbacks[event] then
                table.insert(self._callbacks[event], cb)
            end
            return self
        end,
        _emit = function(self, event, ...)
            local cbs = self._callbacks[event]
            if cbs then
                for _, cb in ipairs(cbs) do
                    cb(...)
                end
            end
        end
    }
end

---@param command string
---@param args string[]
---@param options? { stdin?: string }
function M.spawn(command, args, options)
    options = options or {}
    local process = create_process()

    local stdin = vim.uv.new_pipe(false)
    local stdout = vim.uv.new_pipe(false)
    local stderr = vim.uv.new_pipe(false)

    local handle = {
        process = nil,
        stdin = stdin,
        stdout = stdout,
        stderr = stderr
    }

    function process.abort()
        if process.aborted then return end
        process.aborted = true
        process:_emit('abort')
        if handle.process then
            vim.uv.process_kill(handle.process, 'sigterm')
        end
        vim.uv.close(stdin)
        vim.uv.close(stdout)
        vim.uv.close(stderr)
    end

    handle.process = vim.uv.spawn(command, {
        args = args,
        stdio = { stdin, stdout, stderr }
    }, function(code, signal)
        vim.uv.close(stdin)
        vim.uv.close(stdout)
        vim.uv.close(stderr)
        if handle.process then
            handle.process:close()
        end
        process:_emit('exit', code, signal)
    end)

    stdout:read_start(function(err, chunk)
        if err then
            process:_emit('error', err)
            return
        end
        if chunk then
            process:_emit('stdout', chunk)
        end
    end)

    stderr:read_start(function(err, chunk)
        if err then
            process:_emit('error', err)
            return
        end
        if chunk then
            process:_emit('stderr', chunk)
        end
    end)

    if options.stdin then
        vim.uv.write(stdin, options.stdin, function(err)
            if err then
                process:_emit('error', err)
                return
            end
            vim.uv.shutdown(stdin)
        end)
    else
        vim.uv.close(stdin)
    end

    return process
end

return M
```

## promise

```lua
-- A Promise is in one of these states:
-- * PENDING: initial state, neither fulfilled nor rejected.
-- * FULFILLED: meaning that the operation was completed successfully.
-- * REJECTED: meaning that the operation failed.
local PromiseState = {
    PENDING = 0,
    FULFILLED = 1,
    REJECTED = 2,
}

-- The `Promise` object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.
---@class FittenCode.Concurrency.Promise
---@field state integer
---@field value any
---@field reason any
---@field promise_reactions table
local Promise = {}

-- Promise() constructor, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise
---@param executor? function
---@return FittenCode.Concurrency.Promise
function Promise:new(executor, async)
    assert(type(executor) == 'function', 'Promise executor must be a function')
    local obj = {
        state = PromiseState.PENDING,
        value = nil,
        reason = nil,
        promise_reactions = { {}, {} },
    }
    local function resolve(value)
        if obj.state == PromiseState.PENDING then
            obj.state = PromiseState.FULFILLED
            obj.value = value
            vim.tbl_map(function(callback)
                callback(obj)
            end, obj.promise_reactions[PromiseState.FULFILLED])
        end
    end
    local function reject(reason)
        if obj.state == PromiseState.PENDING then
            obj.state = PromiseState.REJECTED
            obj.reason = reason
            vim.tbl_map(function(callback)
                callback(obj)
            end, obj.promise_reactions[PromiseState.REJECTED])
        end
    end
    if async then
        vim.schedule(function() executor(resolve, reject) end)
    else
        executor(resolve, reject)
    end
    self.__index = self
    return setmetatable(obj, self)
end

-- Promise.prototype.then(), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then
-- * The then() method of Promise instances takes up to two arguments: callback functions for the fulfilled and rejected cases of the Promise.
-- * It immediately returns an equivalent Promise object, allowing you to chain calls to other promise methods.
-- * 当 `原Promise` 被 `拒绝` 且未提供 `on_rejected` 时，`新Promise` 会以相同的原因被 `拒绝`，确保后续的 `catch` 能捕获到 `原始错误`。
---@param on_fulfilled? function
---@param on_rejected? function
---@return FittenCode.Concurrency.Promise
function Promise:forward(on_fulfilled, on_rejected)
    return Promise:new(function(resolve, reject)
        if self.state == PromiseState.PENDING then
            table.insert(self.promise_reactions[PromiseState.FULFILLED], function(promise)
                if on_fulfilled then
                    local last_promise = on_fulfilled(promise.value)
                    if type(last_promise) == 'table' and getmetatable(last_promise) == Promise then
                        last_promise:forward(resolve, reject)
                    else
                        resolve(last_promise)
                    end
                else
                    resolve(promise.value)
                end
            end)
            table.insert(self.promise_reactions[PromiseState.REJECTED], function(promise)
                if on_rejected then
                    local last_promise = on_rejected(promise.reason)
                    if type(last_promise) == 'table' and getmetatable(last_promise) == Promise then
                        last_promise:forward(resolve, reject)
                    else
                        resolve(last_promise)
                    end
                else
                    reject(promise.reason)
                end
            end)
        elseif self.state == PromiseState.FULFILLED then
            if on_fulfilled then
                local last_promise = on_fulfilled(self.value)
                if type(last_promise) == 'table' and getmetatable(last_promise) == Promise then
                    last_promise:forward(resolve, reject)
                else
                    resolve(last_promise)
                end
            else
                resolve(self.value)
            end
        elseif self.state == PromiseState.REJECTED then
            if on_rejected then
                local last_promise = on_rejected(self.reason)
                if type(last_promise) == 'table' and getmetatable(last_promise) == Promise then
                    last_promise:forward(resolve, reject)
                else
                    resolve(last_promise)
                end
            else
                reject(self.reason)
            end
        end
    end)
end
```

## curl.lua

```lua
--[[
-- 其他模块使用 request 示例
local http = require('fittencode.http.request')

local res = http.fetch('https://api.example.com', {
    method = 'POST',
    headers = { ['Content-Type'] = 'application/json' },
    body = vim.json.encode({ query = 'test' })
})

res.stream:on('data', function(chunk)
    print('Received chunk:', chunk)
end)

res.stream:on('end', function(response)
    print('Total response:', response:text())
end)

res.stream:on('error', function(err)
    print('Error:', err.message)
end)

-- 或者使用 Promise
res.promise()
    :forward(function(response)
        print('Success:', response:text())
    end)
    :catch(function(err)
        print('Failed:', err.type)
    end)
--]]

local Promise = require('fittencode.concurrency.promise')
local ProcessSpawn = require('fittencode.process.spawn')

local M = {}

local CURL_TIMING_FORMAT = [[
{
  "timing": {
    "namelookup": %{time_namelookup},
    "connect": %{time_connect},
    "appconnect": %{time_appconnect},
    "pretransfer": %{time_pretransfer},
    "starttransfer": %{time_starttransfer},
    "total": %{time_total},
    "size_download": %{size_download}
  }
}]]

local CURL_ERROR_CODES = {
    [6]  = 'DNS_RESOLUTION_FAILED',
    [7]  = 'CONNECTION_REFUSED',
    [28] = 'TIMEOUT_REACHED',
    [35] = 'SSL_HANDSHAKE_ERROR',
    [47] = 'TOO_MANY_REDIRECTS'
}

local function create_stream()
    return {
        _buffer = '',
        _headers = nil,
        _status = nil,
        _callbacks = {},
        on = function(self, event, cb)
            self._callbacks[event] = cb
            return self
        end,
        _emit = function(self, event, ...)
            local cb = self._callbacks[event]
            if cb then cb(...) end
        end
    }
end

---@param stderr string
local function parse_timing(stderr)
    local json_str = stderr:match('{%b{}}')
    if not json_str then return nil, 'Failed to parse timing data' end
    return vim.json.decode(json_str)
end

---@param url string
function M.fetch(url, options)
    options = options or {}
    local stream = create_stream()
    local handle = { aborted = false }

    -- 构建 curl 参数
    local args = {
        '-s', '-L', '--compressed',
        '--no-buffer', '--tcp-fastopen',
        '--write-out', CURL_TIMING_FORMAT,
        '-X', options.method or 'GET',
    }

    -- 请求头处理
    if options.headers then
        for k, v in pairs(options.headers) do
            table.insert(args, '-H')
            table.insert(args, string.format('%s: %s', k, v))
        end
    end

    -- 请求体处理
    if options.body_file then
        table.insert(args, '--data-binary')
        table.insert(args, '@' .. options.body_file)
    elseif options.body then
        table.insert(args, '--data-binary')
        table.insert(args, '@-')
    end

    table.insert(args, url)

    -- 初始化收集器
    local timing = {}
    local stderr_buffer = {}
    local headers_processed = false

    -- 使用新进程模块
    local process = ProcessSpawn.spawn('curl', args, {
        stdin = options.body
    })

    -- 标准输出处理
    process:on('stdout', function(chunk)
        if handle.aborted then return end

        if not headers_processed then
            local header_end = chunk:find('\r\n\r\n') or chunk:find('\n\n')
            if header_end then
                headers_processed = true
                local header_str = chunk:sub(1, header_end - 1)

                -- 解析状态码
                stream._status = tonumber(header_str:match('HTTP/%d%.%d (%d+)'))

                -- 解析 headers
                local headers = {}
                for line in vim.gsplit(header_str, '\r?\n') do
                    local name, val = line:match('^([^%s:]+):%s*(.*)$')
                    if name then headers[name:lower()] = val end
                end
                stream._headers = headers

                -- 触发 headers 事件
                stream:_emit('headers', {
                    status = stream._status,
                    headers = headers
                })

                -- 处理剩余 body 数据
                local body = chunk:sub(header_end + 4)
                if #body > 0 then
                    stream._buffer = stream._buffer .. body
                    stream:_emit('data', body)
                end
            end
        else
            -- 直接处理 body 数据
            stream._buffer = stream._buffer .. chunk
            stream:_emit('data', chunk)
        end
    end)

    -- 标准错误处理
    process:on('stderr', function(chunk)
        if handle.aborted then return end

        -- 收集计时信息
        local timing_data = parse_timing(chunk)
        if timing_data then
            timing = {
                dns = timing_data.timing.namelookup * 1000,
                tcp = (timing_data.timing.connect - timing_data.timing.namelookup) * 1000,
                ssl = (timing_data.timing.appconnect - timing_data.timing.connect) * 1000,
                ttfb = (timing_data.timing.starttransfer - timing_data.timing.pretransfer) * 1000,
                total = timing_data.timing.total * 1000
            }
        end

        -- 收集原始错误信息
        table.insert(stderr_buffer, chunk)
    end)

    -- 退出处理
    process:on('exit', function(code, signal)
        if handle.aborted then return end

        if code == 0 then
            local response = {
                status = stream._status,
                headers = stream._headers,
                ok = stream._status and (stream._status >= 200 and stream._status < 300) or false,
                timing = timing,
                text = function() return stream._buffer end,
                json = function() return vim.json.decode(stream._buffer) end
            }
            stream:_emit('end', response)
        else
            local error_obj = {
                type = 'CURL_ERROR',
                code = code,
                signal = signal,
                message = table.concat(stderr_buffer),
                timing = timing,
                readable_type = CURL_ERROR_CODES[code] or 'UNKNOWN_ERROR'
            }
            stream:_emit('error', error_obj)
        end
    end)

    -- 错误处理
    process:on('error', function(err)
        stream:_emit('error', {
            type = 'PROCESS_ERROR',
            message = err
        })
    end)

    -- 中止处理
    process:on('abort', function()
        stream:_emit('abort')
    end)

    -- 请求控制方法
    handle.abort = function()
        if not handle.aborted then
            handle.aborted = true
            process.abort()
        end
    end

    return {
        stream = stream,
        abort = handle.abort,
        promise = function()
            return Promise.new(function(resolve, reject)
                stream:on('end', function(response)
                    if response.ok then
                        resolve(response)
                    else
                        reject({
                            type = 'HTTP_ERROR',
                            status = response.status,
                            response = response
                        })
                    end
                end)

                stream:on('error', reject)

                stream:on('abort', function()
                    reject({ type = 'USER_ABORT' })
                end)
            end)
        end
    }
end

return M
```

要求基于以上的 spawn 和 promise 优化如下 curl.lua，使之：
- 对于超大body可以支持指定文件路径，利用curl通过@path来直接传输文件（这是和js fetch不同的地方，因为底层时curl，所以可以利用这个特性）
- 在 curl.lua 上封装一个chunks_curl.lua 用于分块传输大body